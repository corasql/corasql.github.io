#Fabric 1.0 ubuntu1704安装过程
##1、git安装 
<pre>
apt-get install git  
</pre>
查看当前安装git的版本：  
<pre>
git version
</pre>  
验证git是否安装好。
 
##2、golang环境搭建
###(1)安装
<pre>
apt-get install golang
</pre>
####(2)查看go的安装路径
<pre>
go env
</pre>
###(3)配置Go环境变量，对应有{GOROOT,GOPATH,PATH}:  
对应修改路径:	 
<pre>
mkdir /opt/gopath/src/github.com/hyperledger/ -p
vi /etc/profile
  export GOROOT=/usr/lib/go-1.7
  export GOPATH=/opt/gopath
  export PATH=$GOROOT/bin:$GOPATH/bin:$PATH
source /etc/profile
</pre>
##3、docker安装
<pre>
apt install docker docker.io 
systemctl start docker  
systemctl enable docker
</pre> 
##4、安装docker-compose
首先，安装 python-pip 软件包：  
<pre>
apt install python-pip  
</pre>
安装docker-compose版本不低于1.7.0：
<pre>
pip install docker-compose
</pre>
##5、安装相关依赖包
<pre>
apt install libtool libltdl-dev -y
</pre>
##6、获取fabric
<pre>
cd /opt/gopath/src/github.com/hyperledger/
git clone https://github.com/hyperledger/fabric.git
</pre>
##7、构建configtxgen工具
<pre>
cd /opt/gopath/src/github.com/hyperledger/fabric/
chmod 755 ./scripts/goListFiles.sh
make configtxgen
结果将输出以下内容
root@ubuntu-virtual-machine:/opt/gopath/src/github.com/hyperledger/fabric# make configtxgen
build/bin/configtxgen
CGO_CFLAGS=" " GOBIN=/opt/gopath/src/github.com/hyperledger/fabric/build/bin go install -tags "nopkcs11" -ldflags "-X github.com/hyperledger/fabric/common/metadata.Version=1.0.0-alpha3-snapshot-010dcf62 -X github.com/hyperledger/fabric/common/metadata.BaseVersion=0.3.1 -X github.com/hyperledger/fabric/common/metadata.BaseDockerLabel=org.hyperledger.fabric -X github.com/hyperledger/fabric/common/metadata.DockerNamespace=hyperledger -X github.com/hyperledger/fabric/common/metadata.BaseDockerNamespace=hyperledger" github.com/hyperledger/fabric/common/configtx/tool/configtxgen
Binary available as build/bin/configtxgen
</pre>

##8、下载fabric镜像
<pre>
cd /opt/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli
chmod +x download-dockerimages.sh
./download-dockerimages.sh
</pre>
确认镜像  
<pre>
docker images
</pre>

#9、手动执行交易过程
###9.1、配置交易生成器
确保你有配置文件制品（orderer.block 和channel.tx，文件位于
/fabric/examples/e2e_cli/crypto/orderer 目录），如果没有,通过以下命令生成：
<pre>
cd /opt/gopath/src/github.com/hyperledger/fabric/examples/e2e_cli
</pre>
generateCfgTrx.sh 脚本接收一个通道ID 参数（channel-ID）。如果没有提供这个参数，
生成的通道会取默认的通道名mychannel。
命令如下：  
<pre>
./generateCfgTrx.sh mychannel
</pre>
这个脚本执行后，会生成2 个文件orderer.block 和channel.tx。文件位于/fabric/examples/e2e_cli/crypto/orderer 目录。  
**Orderer.block 文件是排序服务的创世区块,  
channel.tx 文件包含了新的通道的配置信息。**  
正如先前描述的，这两个文件都是根据configtx.yaml 文件的配置内容生成，并且包含像加密证书资料和网络节点信息的数据。

###9.2、修改docker-compose 文件
打开docker-compose.yaml 文件，添加注释到script.sh 文件前面，目的是不让它自动执行交易脚本。
<pre>
working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
# command: /bin/bash -c './scripts/script.sh ${CHANNEL_NAME}'
</pre>
保存文件。

###9.3、启动网络
这里使用前面生成配置文件一样的通道名：
<pre>
CHANNEL_NAME=mychannel docker-compose up -d
</pre>

###9.4、创建通道
执行下列命令进入cli 容器，
<pre>
docker exec -it cli bash
</pre>
成功执行命令后，你会看到如下信息：
<pre>
root@db1538155f54:/opt/gopath/src/github.com/hyperledger/fabric/peer#
</pre>
运行如下创建通道命令，通过-c 指定通道名，-f 指定通道配置交易文件，这里的我们是crypto/orderer/channel.tx，你也可以你自己的不同名字的配置交易文件。

因为channel create 命令是针对orderer 容器运行，因此我们需要覆盖先前设置的环境变量，完整的命令如下：
<pre>
CORE_PEER_MSPCONFIGPATH=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/orderer/localMspConfig 
CORE_PEER_LOCALMSPID="OrdererMSP" 
peer channel create -o orderer0:7050 -c mychannel -f crypto/orderer/channel.tx --tls $CORE_PEER_TLS_ENABLED --cafile $GOPATH/src/github.com/hyperledger/fabric/peer/crypto/orderer/localMspConfig/cacerts/ordererOrg0.pem
</pre>
注意：下面的其他命令依然在cli 容器中执行，而且要记住命令里每个peer 对应的环境变量。

###9.5、加入通道
通过命令channel join 加入特定的peer 到通道中，命令如下：
<pre>
CORE_PEER_MSPCONFIGPATH=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer0/localMspConfig 
CORE_PEER_ADDRESS=peer0:7051 
CORE_PEER_LOCALMSPID="Org0MSP" 
CORE_PEER_TLS_ROOTCERT_FILE=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer0/localMspConfig/cacerts/peerOrg0.pem 
peer channel join -b mychannel.block
</pre>
成功执行命令后，可以通过命令docker exec -it peer0 bash 进入到peer0 容器中去验证是否成功加入了通道。切换到如下目录
/var/hyperledger/production/ledgersData/chains/chains
会发现生成了以通道名命名的目录，目录下生成一个名字为blockfile_000000 的文件。通过更改环境变量，可以根据需要加入其它peer 到通道中。
比如，加入peer2 到通道中的命令如下：
<pre>
CORE_PEER_MSPCONFIGPATH=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer2/localMspConfig 
CORE_PEER_ADDRESS=peer2:7051 
CORE_PEER_LOCALMSPID="Org1MSP" 
CORE_PEER_TLS_ROOTCERT_FILE=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer2/localMspConfig/cacerts/peerOrg1.pem 
peer channel join -b mychannel.block
</pre>
加入peer3 到通道中的命令如下：
<pre>
/opt/gopath/src/github.com/hyperledger/fabric/peer# CORE_PEER_MSPCONFIGPATH=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer3/localMspConfig 
CORE_PEER_ADDRESS=peer3:7051 
CORE_PEER_LOCALMSPID="Org1MSP" 
CORE_PEER_TLS_ROOTCERT_FILE=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer3/localMspConfig/cacerts/peerOrg1.pem 
peer channel join -b mychannel.block
</pre>

###9.6、在远程peer 上安装chaincode
安装fabric 提供的例子chaincode 到peer2 上,命令为：
<pre>
CORE_PEER_MSPCONFIGPATH=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer2/localMspConfig CORE_PEER_ADDRESS=peer2:7051 
CORE_PEER_LOCALMSPID="Org1MSP" 
CORE_PEER_TLS_ROOTCERT_FILE=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer2/localMspConfig/cacerts/peerOrg1.pem 
peer chaincode install -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02
</pre>
在peer2 容器的/var/hyperledger/production/chaincodes 目录下发现生成了一个mycc.1.0 文件，这证明了chaincode mycc 安装成功。而在其它同一通道的peer（如peer0,peer3,注意，我们并没有把peer1 加入mychannel 通道）对应的容器里不会有此文件。

###9.7、实例化chaincode 并定义背书策略
在特定peer 上实例化chaincode 会启动一个chaincode 容器，这个chaincode 容器专门为这个特定的peer 工作，然后为chaincode 设置背书策略。此例中定义的背书策略是只要来自Org0 或Org1 的任何一个peer 背书即可。命令如下：
<pre>
# 执行命令前记得设置环境变量。
# 注意传递正确的-C 参数，也就是通道名，我们例子中使用的是mychannel.
CORE_PEER_MSPCONFIGPATH=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer2/localMspConfig 
CORE_PEER_ADDRESS=peer2:7051 
CORE_PEER_LOCALMSPID="Org1MSP" 
CORE_PEER_TLS_ROOTCERT_FILE=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer2/localMspConfig/cacerts/peerOrg1.pem 
peer chaincode instantiate -o orderer0:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $GOPATH/src/github.com/hyperledger/fabric/peer/crypto/orderer/localMspConfig/cacerts/ordererOrg0.pem -C mychannel -n mycc -v 1.0 -p github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02 -c '{"Args":["init","a", "100", "b","200"]}' -P "OR ('Org0MSP.member','Org1MSP.member')"
</pre>
注意这里的的-P 参数的写法，这里的背书策略是："OR ('Org0MSP.member','Org1MSP.member')"

###9.8、调用chaincode
执行invoke 命令前记住设置全局环境变量
<pre>
CORE_PEER_MSPCONFIGPATH=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer2/localMspConfig 
CORE_PEER_ADDRESS=peer2:7051 
CORE_PEER_LOCALMSPID="Org1MSP" CORE_PEER_TLS_ROOTCERT_FILE=$GOPATH/src/github.com/hyperledger/fabric/peer/crypto/peer/peer2/localMspConfig/cacerts/peerOrg1.pem
</pre>
我们在peer2 上执行命令，所以环境变量设置为peer2,执行invoke 命令前，先执行query
命令：
先执行查询命令：
<pre>
peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'
</pre>
查询结果显示：
Query Result: 100
然后执行invoke 命令：
<pre>
peer chaincode invoke -o orderer0:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $GOPATH/src/github.com/hyperledger/fabric/peer/crypto/orderer/localMspConfig/cacerts/ordererOrg0.pem -C mychannel -n mycc -c '{"Args":["invoke","a","b","10"]}'
</pre>
注意，通道名不能错，如果这里写成-C mychannel,必须跟实际创建通道的名字一致。
通道名错误，会报如下错误：
Error: Error endorsing invoke: rpc error: code = 2 desc = Failed to deserialize creator identity, err MSP Org1MSP is unknown
再次执行查询命令（查询a 的值）：
<pre>
peer chaincode query -C mychannel -n mycc -c '{"Args":["query","a"]}'
</pre>
查询结果显示：
Query Result: 90
再次执行查询命令（查询b 的值）：
<pre>
peer chaincode query -C mychannel -n mycc -c '{"Args":["query","b"]}'
</pre>
查询结果显示：
Query Result: 210
如果你细心，就会发现，我们实例化chaincode 的时候b 的值是200，现在是210,再次验证了我们的交易成功执行了。

##10、常见问题：
###(1)docker镜像下载慢问题
由于镜像源在国外，导致下载速度慢，源切换为阿里这边

###(2)如何保存docker images，方便下次或者别人搭建环境
docker save命令-打包image  
打包：  
<pre>
docker save hyperledger/fabric-peer:latest> fabric-peer_latest.tar  
</pre>
导入：
<pre>
docker load < fabric-peer_latest.tar  
</pre>
###(3)、环境清理
用下列命令删除当前运行的容器  
<pre>
docker rm -f $(docker ps -aq)
</pre>




  

